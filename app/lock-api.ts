import * as anchor from "@coral-xyz/anchor";
import { Program, BN } from "@coral-xyz/anchor";
import { Lock } from "./idl/lock_type"; // Import types generated by anchor build
import idl from "./idl/lock.json"; // Import the IDL
import {
  Keypair,
  PublicKey,
  SystemProgram,
  TransactionResponse,
  VersionedTransactionResponse,
} from "@solana/web3.js";
import { TOKEN_PROGRAM_ID, getAssociatedTokenAddress } from "@solana/spl-token";

export interface LockAccountData {
  user: string;
  mint: string;
  amount: string;
  unlockTime: string;
}

export interface DepositEvent {
  user: string;
  mint: string;
  depositedAmount: string; // u64 becomes BN in Anchor/JS
  totalLockedAmount: string; // u64 becomes BN
  unlockTime: string; // i64 becomes BN
}

export interface WithdrawEvent {
  user: string;
  mint: string;
  withdrawnAmount: string;
}

export interface EventWrapper {
  name: "depositEvent" | "withdrawEvent";
  data: DepositEvent | WithdrawEvent;
}

export class LockApi {
  private connection: anchor.web3.Connection;
  private program: Program<Lock>;
  private programId: PublicKey;

  constructor(programId: string, rpcUrl: string) {
    this.connection = new anchor.web3.Connection(rpcUrl, "confirmed");
    this.programId = new PublicKey(programId);
    const provider = new anchor.AnchorProvider(
      this.connection,
      new anchor.Wallet(Keypair.generate()),
      { commitment: "confirmed" }
    );
    this.program = new Program<Lock>(idl as anchor.Idl, provider);
  }

  async deposit(
    user: Keypair,
    mint: string,
    amount: string,
    unlockTime: number
  ): Promise<string> {
    const [lockAccountPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("lock_account"),
        user.publicKey.toBuffer(),
        new PublicKey(mint).toBuffer(),
      ],
      this.programId
    );
    const [vaultTokenAccount] = PublicKey.findProgramAddressSync(
      [Buffer.from("vault_token"), lockAccountPda.toBuffer()],
      this.programId
    );
    const userTokenAccount = await getAssociatedTokenAddress(
      new PublicKey(mint),
      user.publicKey
    );
    const program = this.newSignableProgram(user);
    return await program.methods
      .deposit(new BN(amount), new BN(unlockTime))
      .accounts({
        user: user.publicKey,
        userTokenAccount: userTokenAccount,
        mint,
        vaultTokenAccount: vaultTokenAccount,
        lockAccount: lockAccountPda,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      } as unknown as anchor.Accounts)
      .rpc();
  }

  async withdraw(user: Keypair, mint: string): Promise<string> {
    const mintPublicKey = new PublicKey(mint);
    const [lockAccountPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("lock_account"),
        user.publicKey.toBuffer(),
        mintPublicKey.toBuffer(),
      ],
      this.programId
    );
    const [vaultTokenAccountPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("vault_token"), lockAccountPda.toBuffer()],
      this.programId
    );
    const userTokenAccount = await getAssociatedTokenAddress(
      mintPublicKey,
      user.publicKey
    );
    const program = this.newSignableProgram(user);
    return await program.methods
      .withdraw()
      .accounts({
        user: user.publicKey,
        userTokenAccount,
        mint,
        vaultTokenAccount: vaultTokenAccountPda,
        lockAccount: lockAccountPda,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      } as unknown as anchor.Accounts)
      .rpc();
  }

  async getLockAccountData(
    mint: string,
    user: string
  ): Promise<LockAccountData> {
    const [lock] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("lock_account"),
        new PublicKey(user).toBuffer(),
        new PublicKey(mint).toBuffer(),
      ],
      this.programId
    );
    const data = await this.program.account.lockAccount.fetch(lock);
    return {
      user: data.user.toBase58(),
      mint: data.mint.toBase58(),
      amount: data.amount.toString(),
      unlockTime: data.unlockTime.toString(),
    };
  }

  async readEventsFromTransaction(
    signature: string
  ): Promise<EventWrapper[] | undefined> {
    const tx: TransactionResponse | VersionedTransactionResponse | null =
      await this.connection.getTransaction(signature, {
        maxSupportedTransactionVersion: 0, // Specify version if known, 0 is common for recent
        commitment: "confirmed",
      });

    if (!tx) {
      return;
    }

    if (tx.meta?.err) {
      return;
    }

    const logs = tx.meta?.logMessages;
    if (!logs) {
      return;
    }

    const result: EventWrapper[] = [];
    for (const log of logs) {
      let eventLog = log;
      if (eventLog.startsWith("Program data:")) {
        eventLog = eventLog.replace("Program data: ", "");
      }
      const event = this.program.coder.events.decode(eventLog);
      if (event) {
        switch (event.name) {
          case "depositEvent":
            result.push({
              name: "depositEvent",
              data: {
                user: event.data.user.toBase58(),
                mint: event.data.mint.toBase58(),
                depositedAmount: event.data.depositedAmount.toString(),
                totalLockedAmount: event.data.totalLockedAmount.toString(),
                unlockTime: event.data.unlockTime.toString(),
              },
            });
            break;
          case "withdrawEvent":
            result.push({
              name: "withdrawEvent",
              data: {
                user: event.data.user.toBase58(),
                mint: event.data.mint.toBase58(),
                withdrawnAmount: event.data.withdrawnAmount.toString(),
              },
            });
            break;
        }
      }
    }
    if (result.length === 0) {
      return;
    }
    return result;
  }

  private newSignableProgram(user: Keypair): Program<Lock> {
    const provider = new anchor.AnchorProvider(
      this.connection,
      new anchor.Wallet(user),
      { commitment: "confirmed" }
    );
    return new Program<Lock>(idl as anchor.Idl, provider);
  }
}
