import * as anchor from "@coral-xyz/anchor";
import { Program, BN } from "@coral-xyz/anchor";
import { Lock } from "../target/types/lock"; // Import types generated by anchor build
import {
  Keypair,
  PublicKey,
  SystemProgram,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import {
  TOKEN_PROGRAM_ID,
  createMint,
  createAssociatedTokenAccount,
  mintTo,
  getAccount, // To fetch token account info
  getAssociatedTokenAddressSync,
} from "@solana/spl-token";
import { assert } from "chai";

// Helper function to wait
const sleep = (ms: number): Promise<void> =>
  new Promise((resolve) => setTimeout(resolve, ms));

describe("lock", () => {
  // Configure the client to use the local cluster.
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Lock as Program<Lock>;
  const payer = provider.wallet as anchor.Wallet; // Use the provider's wallet as the payer/user

  // Keypairs and addresses to be initialized
  let mintKp: Keypair;
  let mintPubkey: PublicKey;
  let userTokenAccountPubkey: PublicKey;
  let lockAccountPda: PublicKey;
  let lockAccountBump: number;
  let vaultTokenAccountPda: PublicKey;
  // vaultTokenAccountBump is implicitly handled by Anchor's seeds constraint check

  const initialMintAmount = new BN(1000 * 10 ** 6); // Example: 1000 tokens with 6 decimals
  const decimals = 6; // Example decimals

  before(async () => {
    // --- Setup ---
    // 1. Generate a new mint
    mintKp = Keypair.generate();
    mintPubkey = mintKp.publicKey;

    console.log("Creating Mint...");
    await createMint(
      provider.connection,
      payer.payer, // Payer for transaction fees
      payer.publicKey, // Mint authority
      null, // Freeze authority (optional)
      decimals, // Decimals
      mintKp // Mint keypair
    );
    console.log(`   Mint Pubkey: ${mintPubkey.toBase58()}`);

    // 2. Create User's Associated Token Account (ATA)
    console.log("Creating User ATA...");
    userTokenAccountPubkey = await createAssociatedTokenAccount(
      provider.connection,
      payer.payer, // Payer
      mintPubkey, // Mint
      payer.publicKey // Owner
    );
    console.log(`   User ATA: ${userTokenAccountPubkey.toBase58()}`);

    // 3. Mint initial tokens to User's ATA
    console.log("Minting initial tokens to User ATA...");
    await mintTo(
      provider.connection,
      payer.payer, // Payer
      mintPubkey, // Mint
      userTokenAccountPubkey, // Destination ATA
      payer.publicKey, // Mint Authority
      initialMintAmount.toNumber() // Amount (ensure it's within JS number limits for mintTo)
    );
    const initialBalance = await provider.connection.getTokenAccountBalance(
      userTokenAccountPubkey
    );
    console.log(
      `   Initial User ATA Balance: ${initialBalance.value.uiAmount}`
    );
    assert.strictEqual(
      initialBalance.value.amount,
      initialMintAmount.toString(),
      "Initial minting failed"
    );

    // 4. Derive PDA Addresses
    // PDA for Lock Metadata Account
    [lockAccountPda, lockAccountBump] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("lock_account"),
        payer.publicKey.toBuffer(),
        mintPubkey.toBuffer(),
      ],
      program.programId
    );

    // PDA for Vault Token Account (owned by lockAccountPda)
    // Its seeds depend on the lockAccountPda as defined in the Rust code
    [vaultTokenAccountPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("vault_token"),
        lockAccountPda.toBuffer(), // Seed with the lock account's public key
      ],
      program.programId
    );

    console.log(`   Lock Account PDA: ${lockAccountPda.toBase58()}`);
    console.log(
      `   Vault Token Account PDA: ${vaultTokenAccountPda.toBase58()}`
    );
  });

  // --- Test Cases ---

  it("Deposits tokens for the first time", async () => {
    const depositAmount = new BN(100 * 10 ** decimals);
    // Set unlock time 10 seconds from now
    const unlockTimestamp = new BN(Math.floor(Date.now() / 1000) + 10);

    console.log(`\nAttempting first deposit of ${depositAmount.toString()}...`);
    console.log(`   Target Unlock Time: ${unlockTimestamp.toString()}`);

    await program.methods
      .deposit(depositAmount, unlockTimestamp)
      .accounts({
        user: payer.publicKey,
        userTokenAccount: userTokenAccountPubkey,
        mint: mintPubkey,
        vaultTokenAccount: vaultTokenAccountPda, // Pass the derived PDA address
        lockAccount: lockAccountPda, // Pass the derived PDA address
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY, // Rent sysvar needed for init_if_needed
      })
      .signers([payer.payer]) // Signer might be needed depending on provider setup
      .rpc();

    console.log("   Deposit successful.");

    // Verification
    const lockAccountState = await program.account.lockAccount.fetch(
      lockAccountPda
    );
    const vaultBalance = await provider.connection.getTokenAccountBalance(
      vaultTokenAccountPda
    );
    const userBalance = await provider.connection.getTokenAccountBalance(
      userTokenAccountPubkey
    );

    assert.ok(
      lockAccountState.user.equals(payer.publicKey),
      "Lock account user mismatch"
    );
    assert.ok(
      lockAccountState.mint.equals(mintPubkey),
      "Lock account mint mismatch"
    );
    assert.strictEqual(
      lockAccountState.amount.toString(),
      depositAmount.toString(),
      "Lock account amount incorrect"
    );
    assert.strictEqual(
      lockAccountState.unlockTime.toString(),
      unlockTimestamp.toString(),
      "Lock account unlock time incorrect"
    );
    assert.strictEqual(
      lockAccountState.bump,
      lockAccountBump,
      "Lock account bump incorrect"
    );
    assert.strictEqual(
      vaultBalance.value.amount,
      depositAmount.toString(),
      "Vault balance incorrect after deposit"
    );

    const expectedUserBalance = initialMintAmount.sub(depositAmount);
    assert.strictEqual(
      userBalance.value.amount,
      expectedUserBalance.toString(),
      "User balance incorrect after deposit"
    );
    console.log("   State verified.");
  });

  it("Deposits more tokens with a later unlock time", async () => {
    const previousLockState = await program.account.lockAccount.fetch(
      lockAccountPda
    );
    const previousAmount = previousLockState.amount;
    const previousUnlockTime = previousLockState.unlockTime;

    const depositAmount = new BN(50 * 10 ** decimals);
    // Set new unlock time 20 seconds from now (must be >= previousUnlockTime)
    const newUnlockTimestamp = new BN(Math.floor(Date.now() / 1000) + 20);
    assert.ok(
      newUnlockTimestamp.gte(previousUnlockTime),
      "New unlock time must be >= previous"
    );

    console.log(
      `\nAttempting subsequent deposit of ${depositAmount.toString()}...`
    );
    console.log(`   Target Unlock Time: ${newUnlockTimestamp.toString()}`);

    await program.methods
      .deposit(depositAmount, newUnlockTimestamp)
      .accounts({
        user: payer.publicKey,
        userTokenAccount: userTokenAccountPubkey,
        mint: mintPubkey,
        vaultTokenAccount: vaultTokenAccountPda,
        lockAccount: lockAccountPda,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      })
      .signers([payer.payer])
      .rpc();

    console.log("   Subsequent deposit successful.");

    // Verification
    const currentLockState = await program.account.lockAccount.fetch(
      lockAccountPda
    );
    const vaultBalance = await provider.connection.getTokenAccountBalance(
      vaultTokenAccountPda
    );

    const expectedTotalAmount = previousAmount.add(depositAmount);
    assert.strictEqual(
      currentLockState.amount.toString(),
      expectedTotalAmount.toString(),
      "Lock amount accumulation incorrect"
    );
    assert.strictEqual(
      currentLockState.unlockTime.toString(),
      newUnlockTimestamp.toString(),
      "Lock unlock time update incorrect"
    );
    assert.strictEqual(
      vaultBalance.value.amount,
      expectedTotalAmount.toString(),
      "Vault balance incorrect after subsequent deposit"
    );
    console.log("   State verified.");
  });

  it("Fails to deposit with an earlier unlock time", async () => {
    const currentLockState = await program.account.lockAccount.fetch(
      lockAccountPda
    );
    const currentUnlockTime = currentLockState.unlockTime;

    const depositAmount = new BN(10 * 10 ** decimals);
    // Set unlock time 5 seconds from now (which is likely < currentUnlockTime set previously)
    const invalidUnlockTimestamp = new BN(Math.floor(Date.now() / 1000) + 5);
    assert.ok(
      invalidUnlockTimestamp.lt(currentUnlockTime),
      "Test setup invalid: invalid time must be less than current"
    );

    console.log(
      `\nAttempting deposit with invalid unlock time ${invalidUnlockTimestamp.toString()}...`
    );

    try {
      await program.methods
        .deposit(depositAmount, invalidUnlockTimestamp)
        .accounts({
          user: payer.publicKey,
          userTokenAccount: userTokenAccountPubkey,
          mint: mintPubkey,
          vaultTokenAccount: vaultTokenAccountPda,
          lockAccount: lockAccountPda,
          systemProgram: SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        })
        .signers([payer.payer])
        .rpc();
      assert.fail("Transaction should have failed due to invalid unlock time.");
    } catch (err) {
      // Check for the specific error from the program
      // console.error(JSON.stringify(err, null, 2)); // Log error details for debugging
      assert.include(
        err.toString(),
        "UnlockTimeMustBeGreaterOrEqual",
        "Incorrect error thrown"
      );
      console.log("   Transaction failed as expected.");
    }
  });

  it("Fails to withdraw before unlock time", async () => {
    console.log("\nAttempting to withdraw before unlock time...");
    try {
      await program.methods
        .withdraw()
        .accounts({
          user: payer.publicKey,
          userTokenAccount: userTokenAccountPubkey,
          mint: mintPubkey,
          vaultTokenAccount: vaultTokenAccountPda,
          lockAccount: lockAccountPda,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([payer.payer])
        .rpc();
      assert.fail(
        "Withdrawal should have failed because funds are still locked."
      );
    } catch (err) {
      // console.error(JSON.stringify(err, null, 2)); // Log error details for debugging
      assert.include(
        err.toString(),
        "StillLocked",
        "Incorrect error for early withdrawal"
      );
      console.log("   Withdrawal failed as expected (still locked).");
    }
  });

  it("Withdraws tokens successfully after unlock time", async () => {
    const lockStateBeforeWithdraw = await program.account.lockAccount.fetch(
      lockAccountPda
    );
    const amountToWithdraw = lockStateBeforeWithdraw.amount;
    const unlockTime = lockStateBeforeWithdraw.unlockTime;
    const userBalanceBefore = await provider.connection.getTokenAccountBalance(
      userTokenAccountPubkey
    );

    // Calculate wait time
    const currentTime = Math.floor(Date.now() / 1000);
    const waitSeconds = unlockTime.toNumber() - currentTime + 2; // Wait until 2s past unlock time

    console.log(
      `\nWaiting for unlock time... (Current: ${currentTime}, Unlock: ${unlockTime.toNumber()})`
    );
    if (waitSeconds > 0) {
      console.log(`   Waiting for ${waitSeconds} seconds...`);
      await sleep(waitSeconds * 1000);
    } else {
      console.log("   Unlock time has already passed.");
    }

    console.log("Attempting to withdraw after unlock time...");
    await program.methods
      .withdraw()
      .accounts({
        user: payer.publicKey,
        userTokenAccount: userTokenAccountPubkey,
        mint: mintPubkey,
        vaultTokenAccount: vaultTokenAccountPda,
        lockAccount: lockAccountPda,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([payer.payer])
      .rpc();
    console.log("   Withdrawal successful.");

    // Verification
    const lockStateAfterWithdraw = await program.account.lockAccount.fetch(
      lockAccountPda
    );
    const vaultBalanceAfter = await provider.connection.getTokenAccountBalance(
      vaultTokenAccountPda
    );
    const userBalanceAfter = await provider.connection.getTokenAccountBalance(
      userTokenAccountPubkey
    );

    assert.strictEqual(
      lockStateAfterWithdraw.amount.toString(),
      "0",
      "Lock account amount not reset"
    );
    // assert.strictEqual(lockStateAfterWithdraw.unlockTime.toString(), "0", "Lock account unlock time not reset"); // Check if you reset it in withdraw
    assert.strictEqual(
      vaultBalanceAfter.value.amount,
      "0",
      "Vault balance not zero after withdraw"
    );

    const expectedUserBalance = new BN(userBalanceBefore.value.amount).add(
      amountToWithdraw
    );
    assert.strictEqual(
      userBalanceAfter.value.amount,
      expectedUserBalance.toString(),
      "User balance incorrect after withdrawal"
    );
    console.log("   State verified after withdrawal.");
  });

  it("Fails to withdraw when vault is empty", async () => {
    console.log("\nAttempting to withdraw when vault is empty...");
    try {
      await program.methods
        .withdraw()
        .accounts({
          user: payer.publicKey,
          userTokenAccount: userTokenAccountPubkey,
          mint: mintPubkey,
          vaultTokenAccount: vaultTokenAccountPda,
          lockAccount: lockAccountPda,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([payer.payer])
        .rpc();
      assert.fail("Withdrawal should have failed because vault is empty.");
    } catch (err) {
      // console.error(JSON.stringify(err, null, 2)); // Log error details for debugging
      assert.include(
        err.toString(),
        "NoTokensLocked",
        "Incorrect error for empty withdrawal"
      );
      console.log("   Withdrawal failed as expected (no tokens locked).");
    }
  });
});
